(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{205:function(t,e,r){"use strict";r.r(e);var s=r(0),a=Object(s.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h3",{attrs:{id:"了解ssr"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#了解ssr"}},[t._v("#")]),t._v(" 了解ssr")]),t._v(" "),r("h4",{attrs:{id:"什么事服务端渲染"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么事服务端渲染"}},[t._v("#")]),t._v(" 什么事服务端渲染")]),t._v(" "),r("p",[t._v("服务端渲染也称作 SSR(Server Side Render) 。不同于客户端渲染，服务端渲染会在后端把页面 DOM 的结构树转成 String 吐出来，然后到前端（如浏览器）解析渲染。")]),t._v(" "),r("h4",{attrs:{id:"服务端渲染的优势"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#服务端渲染的优势"}},[t._v("#")]),t._v(" 服务端渲染的优势")]),t._v(" "),r("blockquote",[r("p",[t._v("seo\n现在单页面应用由于体验好，广泛流行。但单页应用的做法往往是后端只吐出一个页面的框架，里面没有具体内容，然后前端通过 Ajax 动态拉取内容。这就导致爬虫去访问你的站点时，服务端返回给爬虫的只有一个架子，爬虫无法抓取页面关键词之类等信息。")])]),t._v(" "),r("blockquote",[r("p",[t._v("首屏直出\n意思很好理解，就是在用户首次访问的时候不用再看到菊花在那里转呀转 (Loading...) ，首屏就可以看到页面所有内容。另外可以在服务端通过 HTTP 接口合并请求等方式，让页面打开的首屏时间缩短。")])]),t._v(" "),r("h4",{attrs:{id:"服务端渲染资源加载问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#服务端渲染资源加载问题"}},[t._v("#")]),t._v(" 服务端渲染资源加载问题")]),t._v(" "),r("p",[t._v("node require 默认就只支持加载 .json .js 等几种文件，所以如何保证客户端渲染出来的代码跟服务端渲染出来的代码一致呢（在 react 应用中，react 会检查客户端渲染出来的结构是否跟客户端渲染出来的一致，如果不一致的话，会在客户端重渲染）？这里提供两套思路：")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("客户端跟服务端用同一套 webpack 打包后的资源。webpack-isomorphic-tools 可以很好的解决这个问题，或者最新的 webpack 版本 target: node 也能实现。")])]),t._v(" "),r("li",[r("p",[t._v("png/jpg/font 等文件直接忽略（在 babel-register 里可以设置），scss/css的话，用 css in js 的方式写。")])])]),t._v(" "),r("h4",{attrs:{id:"存在问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#存在问题"}},[t._v("#")]),t._v(" 存在问题")]),t._v(" "),r("p",[t._v("首当其冲的就是服务器 cpu 过高问题，因为现在页面结构是在服务端以 renderToString 的方式输出，所以页面请求路由会涉及到大量的计算。这就会导致如果页面并发高一点的话，会出现 cpu 过高的问题。")]),t._v(" "),r("p",[t._v("另外在服务端可没有什么 window 、 document 对象，这些东西也需要去 hook 掉；在 React 应用中，componentDidMount 等生命周期函数也不会在服务端触发；定时器记得及时释放，否则可能会导致内存泄露的风险！")]),t._v(" "),r("p",[t._v("采用的成熟的框架 vue 体系下的 Nuxt.js\nreact 体系下比较有代表性的 next.js")]),t._v(" "),r("h4",{attrs:{id:"导致cpu占用高的原因"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#导致cpu占用高的原因"}},[t._v("#")]),t._v(" 导致cpu占用高的原因")]),t._v(" "),r("ul",[r("li",[t._v("renderToString输出，页面请求路由会涉及到大量的计算，并发高导致cpu占用高")]),t._v(" "),r("li",[t._v("定时器释放，考虑内存泄露的风险")]),t._v(" "),r("li",[t._v("QPS查询")]),t._v(" "),r("li",[t._v("每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。")])]),t._v(" "),r("h4",{attrs:{id:"前端加载优化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#前端加载优化"}},[t._v("#")]),t._v(" 前端加载优化")]),t._v(" "),r("ul",[r("li",[t._v("Code Split")]),t._v(" "),r("li",[t._v("动态加载方案（dynamic import）")])]),t._v(" "),r("h4",{attrs:{id:"vue-ssr-文档"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vue-ssr-文档"}},[t._v("#")]),t._v(" VUE SSR 文档")]),t._v(" "),r("ul",[r("li",[t._v("避免在beforeCreate 和 created产生副作用代码")])]),t._v(" "),r("p",[t._v("此外还需要注意的是，你应该避免在 beforeCreate 和 created 生命周期时产生全局副作用的代码，例如在其中使用 setInterval 设置 timer。在纯客户端(client-side only)的代码中，我们可以设置一个 timer，然后在 beforeDestroy 或 destroyed 生命周期时将其销毁。但是，由于在 SSR 期间并不会调用销毁钩子函数，所以 timer 将永远保留下来。为了避免这种情况，请将副作用代码移动到 beforeMount 或 mounted 生命周期中。")])])}),[],!1,null,null,null);e.default=a.exports}}]);